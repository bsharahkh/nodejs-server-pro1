=== FILE: D:\projects web\Private me\Server2\backend\.gitignore ===
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*





=== FILE: D:\projects web\Private me\Server2\backend\package.json ===
{
  "name": "clean-rest-api",
  "version": "1.0.0",
  "private": true,
  "type": "commonjs",
  "main": "src/server.js",
  "scripts": {
    "start": "NODE_ENV=production node src/server.js",
    "dev": "node src/config/swagger/swagger.js && nodemon src/server.js",
    "migrate": "node ./scripts/run-migrations.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.6.1",
    "express": "^4.19.2",
    "express-rate-limit": "^7.4.0",
    "google-auth-library": "^9.0.0",
    "helmet": "^7.1.0",
    "joi": "^17.12.3",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "nodemailer": "^6.9.8",
    "pg": "^8.12.0",
    "swagger-autogen": "^2.23.7",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1"
  },
  "devDependencies": {
    "nodemon": "^3.1.0"
  }
}



=== FILE: D:\projects web\Private me\Server2\backend\migrations\001_init.sql ===
-- Users and auth
CREATE TABLE IF NOT EXISTS users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password TEXT,
  verified BOOLEAN DEFAULT FALSE,
  verify_code VARCHAR(6),
  reset_code VARCHAR(6),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS roles (
  id SERIAL PRIMARY KEY,
  role TEXT UNIQUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO roles (role) VALUES ('user') ON CONFLICT DO NOTHING;
INSERT INTO roles (role) VALUES ('admin') ON CONFLICT DO NOTHING;

CREATE TABLE IF NOT EXISTS user_roles (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  role TEXT NOT NULL REFERENCES roles(role) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS claims (
  id SERIAL PRIMARY KEY,
  claim TEXT UNIQUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS user_claims (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  claim TEXT NOT NULL REFERENCES claims(claim) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


CREATE TABLE IF NOT EXISTS books (
  id SERIAL PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  description TEXT,
  active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS books_details (
  id SERIAL PRIMARY KEY,
  book_id INTEGER NOT NULL REFERENCES books(id) ON DELETE CASCADE,
  name TEXT UNIQUE NOT NULL,
  description TEXT,
  book_data TEXT,
  active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS tiers (
  id SERIAL PRIMARY KEY,
  name TEXT UNIQUE NOT NULL,
  description TEXT,
  price NUMERIC(20,9) DEFAULT 0,
  duration_days INTEGER DEFAULT 30,
  active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS user_subscriptions (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  tier_id INTEGER NOT NULL REFERENCES tiers(id) ON DELETE CASCADE,
  start_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  end_date TIMESTAMP,
  active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS tier_book_access (
  id SERIAL PRIMARY KEY,
  tier_id INTEGER NOT NULL REFERENCES tiers(id) ON DELETE CASCADE,
  book_id INTEGER NOT NULL REFERENCES books(id) ON DELETE CASCADE,
  book_details_id INTEGER REFERENCES books_details(id) ON DELETE CASCADE,
  unlock_delay_minutes INTEGER DEFAULT 0,
  required BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (tier_id, book_id, book_details_id)
);

CREATE TABLE IF NOT EXISTS user_book_access_log (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  book_detail_id INTEGER NOT NULL REFERENCES books_details(id) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS user_log (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  data JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS system_log (
  id SERIAL PRIMARY KEY,
  data JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Useful indexes
CREATE INDEX IF NOT EXISTS idx_books_name ON books USING gin (to_tsvector('simple', name));
CREATE INDEX IF NOT EXISTS idx_user_roles_user ON user_roles(user_id);
CREATE INDEX IF NOT EXISTS idx_tier_book_access ON tier_book_access(tier_id, book_id, book_details_id);
CREATE INDEX IF NOT EXISTS idx_user_book_access_log_user ON user_book_access_log(user_id);



=== FILE: D:\projects web\Private me\Server2\backend\scripts\run-migrations.js ===
const fs = require("fs");
const path = require("path");
const pool = require("../src/db"); // your pg pool

(async () => {
  const client = await pool.connect();

  try {
    await client.query("BEGIN");

    // keep track of applied migrations
    await client.query(`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        name TEXT UNIQUE NOT NULL,
        run_on TIMESTAMP NOT NULL DEFAULT NOW()
      )
    `);

    const migrationsDir = path.join(__dirname, "../migrations");
    const files = fs
      .readdirSync(migrationsDir)
      .filter((f) => f.endsWith(".sql"));

    for (const file of files) {
      const applied = await client.query(
        "SELECT 1 FROM migrations WHERE name = $1",
        [file]
      );

      if (applied.rowCount === 0) {
        // const sql = fs.readFileSync(path.join(migrationsDir, file), "utf-8");

        const sql = fs
          .readFileSync(path.join(migrationsDir, file), "utf-8")
          .replace(/^\uFEFF/, ""); // strip BOM if exists

        console.log(`Running migration: ${file}`);
        await client.query(sql);
        await client.query("INSERT INTO migrations (name) VALUES ($1)", [file]);
      }
    }

    await client.query("COMMIT");
    console.log("✅ All migrations applied");
  } catch (err) {
    await client.query("ROLLBACK");
    console.error("❌ Migration failed:", err);
    process.exit(1);
  } finally {
    client.release();
    await pool.end();
  }
})();




=== FILE: D:\projects web\Private me\Server2\backend\src\app.js ===
const express = require("express");
const cors = require("cors");
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");
const morgan = require("morgan");
const path = require("path");
const { CORS_ORIGIN, NODE_ENV } = require("./config");
const router = require("./routes");
const errorHandler = require("./middleware/errorHandler");

const app = express();

// Security & utils
app.use(helmet());
app.use(
  cors({ origin: CORS_ORIGIN === "*" ? true : CORS_ORIGIN, credentials: true })
);
app.use(express.json({ limit: "1mb" }));
app.use(express.urlencoded({ extended: true }));
app.use(morgan(NODE_ENV === "production" ? "combined" : "dev"));

// swagger
if (NODE_ENV === "development") {
  const swaggerUi = require("swagger-ui-express");
  const swaggerFile = require("./config/swagger/swagger-output.json");

  app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerFile));
}

// Basic rate limit for auth endpoints
const authLimiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 100 });
app.use("/api/auth", authLimiter);

// API routes
app.use("/api", router);

// Serve static Angular (optional) � put your built app under public/www
app.use(express.static(path.join(__dirname, "../public/www")));
app.get("*", (req, res) =>
  res.sendFile(path.join(__dirname, "../public/www/index.html"))
);

// Error handler (keep last)
app.use(errorHandler);

module.exports = app;




=== FILE: D:\projects web\Private me\Server2\backend\src\server.js ===
require("dotenv").config();
const app = require("./app");
const { PORT } = require("./config");

app.listen(PORT, () => {
  // eslint-disable-next-line no-console
  console.log(`Server listening on http://localhost:${PORT}`);
  console.log(`?? Swagger docs at http://localhost:${PORT}/api-docs`);
});




=== FILE: D:\projects web\Private me\Server2\backend\src\config\index.js ===
require("dotenv").config();

const required = (key) => {
  if (!process.env[key]) throw new Error(`Missing env: ${key}`);
  return process.env[key];
};

module.exports = {
  PORT: process.env.PORT || 3000,
  NODE_ENV: process.env.NODE_ENV || "development",
  CORS_ORIGIN: process.env.CORS_ORIGIN || "*",

  DB: {
    host: required("DB_HOST"),
    port: parseInt(process.env.DB_PORT || "5432", 10),
    user: required("DB_USER"),
    password: required("DB_PASSWORD"),
    database: required("DB_DATABASE"),
  },

  JWT: {
    secret: required("JWT_SECRET"),
    expiresIn: process.env.JWT_EXPIRES_IN || "7d",
  },

  EMAIL: {
    host: process.env.EMAIL_HOST,
    port: parseInt(process.env.EMAIL_PORT || "587", 10),
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },

  GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID,
};




=== FILE: D:\projects web\Private me\Server2\backend\src\config\swagger\swagger-output.json ===
{
  "swagger": "2.0",
  "info": {
    "title": "Clean REST API",
    "description": "Auto-generated API documentation",
    "version": "1.0.0"
  },
  "host": "localhost:3000",
  "basePath": "/",
  "schemes": [
    "http"
  ],
  "paths": {
    "/api/auth/signup": {
      "post": {
        "description": "",
        "responses": {
          "201": {
            "description": "Created"
          }
        }
      }
    },
    "/api/auth/login": {
      "post": {
        "description": "",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/auth/verify-email": {
      "post": {
        "description": "",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/auth/reset/send-code": {
      "post": {
        "description": "",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/auth/reset/verify": {
      "post": {
        "description": "",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/auth/google": {
      "post": {
        "description": "",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/users/me": {
      "get": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          }
        }
      }
    },
    "/api/users/me/subscribe": {
      "post": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "schema": {
              "type": "object",
              "properties": {
                "tier_id": {
                  "example": "any"
                }
              }
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Created"
          },
          "401": {
            "description": "Unauthorized"
          }
        }
      }
    },
    "/api/users/me/subscriptions": {
      "get": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          }
        }
      }
    },
    "/api/users/me/access-log": {
      "get": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          }
        }
      }
    },
    "/api/books/": {
      "get": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          }
        }
      },
      "post": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "201": {
            "description": "Created"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      }
    },
    "/api/books/{bookId}/details": {
      "get": {
        "description": "",
        "parameters": [
          {
            "name": "bookId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          }
        }
      }
    },
    "/api/books/details/{detailId}": {
      "get": {
        "description": "",
        "parameters": [
          {
            "name": "detailId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          }
        }
      }
    },
    "/api/books/{id}": {
      "put": {
        "description": "",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      },
      "delete": {
        "description": "",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      }
    },
    "/api/books/details/": {
      "post": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "201": {
            "description": "Created"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      }
    },
    "/api/books/details/{id}": {
      "put": {
        "description": "",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      },
      "delete": {
        "description": "",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      }
    },
    "/api/tiers/": {
      "post": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "201": {
            "description": "Created"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      },
      "get": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      }
    },
    "/api/tiers/{id}": {
      "put": {
        "description": "",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      },
      "delete": {
        "description": "",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "No Content"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      }
    },
    "/api/tiers/{id}/access": {
      "put": {
        "description": "",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      }
    },
    "/api/tiers/_admin/subscriptions": {
      "get": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      }
    },
    "/api/tiers/_admin/access-logs": {
      "get": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          }
        }
      }
    },
    "/api/access/books": {
      "get": {
        "description": "",
        "parameters": [
          {
            "name": "slice(7",
            "in": "header",
            "type": "string"
          },
          {
            "name": "page",
            "in": "query",
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "type": "string"
          },
          {
            "name": "order",
            "in": "query",
            "type": "string"
          },
          {
            "name": "name",
            "in": "query",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "401": {
            "description": "Unauthorized"
          }
        }
      }
    }
  }
}



=== FILE: D:\projects web\Private me\Server2\backend\src\config\swagger\swagger.js ===
const swaggerAutogen = require("swagger-autogen")();

const doc = {
  info: {
    title: "Clean REST API",
    description: "Auto-generated API documentation",
  },
  host: "localhost:3000",
  schemes: ["http"],
};

const outputFile = "./swagger-output.json";
const endpointsFiles = ["../../app.js"]; // entry for all routes

swaggerAutogen(outputFile, endpointsFiles, doc);




=== FILE: D:\projects web\Private me\Server2\backend\src\db\index.js ===
const { Pool } = require("pg");
const { DB } = require("../config");

const pool = new Pool(DB);

pool.on("error", (err) => {
  // eslint-disable-next-line no-console
  console.error("Unexpected PG error", err);
  process.exit(-1);
});

module.exports = pool;




=== FILE: D:\projects web\Private me\Server2\backend\src\middleware\auth.js ===
const jwt = require("jsonwebtoken");
const { JWT } = require("../config");

module.exports = function auth(req, res, next) {
  const header = req.headers["authorization"] || "";
  const token = header.startsWith("Bearer ") ? header.slice(7) : null;
  if (!token)
    return res.status(401).json({ message: "Authorization token missing" });
  try {
    req.user = jwt.verify(token, JWT.secret);
    next();
  } catch (e) {
    return res.status(401).json({ message: "Invalid or expired token" });
  }
};




=== FILE: D:\projects web\Private me\Server2\backend\src\middleware\errorHandler.js ===
module.exports = (err, req, res, next) => {
  // eslint-disable-next-line no-console
  console.error(err);
  const status = err.status || 500;
  const message = err.message || "Internal Server Error";
  const details = err.details || undefined;
  return res.status(status).json({ message, details });
};




=== FILE: D:\projects web\Private me\Server2\backend\src\middleware\role.js ===
module.exports = (role) => (req, res, next) => {
  const roles = req.user?.roles || [];
  if (!roles.includes(role))
    return res.status(403).json({ message: "Forbidden" });
  next();
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\access\access.controller.js ===
const svc = require("./access.service");

exports.availableBooks = async (req, res, next) => {
  try {
    const out = await svc.listAvailableBooks({
      userId: req.user.userId,
      isAdmin: req.user?.roles?.includes("admin"),
      page: parseInt(req.query.page || "1", 10),
      pageSize: parseInt(req.query.pageSize || "10", 10),
      order: req.query.order || "asc",
      name: req.query.name || "",
    });
    res.json(out);
  } catch (e) {
    next(e);
  }
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\access\access.repository.js ===
const pool = require("../../db");

exports.getUserTierIdsActive = async ({ userId, isAdmin }) => {
  const { rows } = await pool.query(
    `SELECT tier_id FROM user_subscriptions WHERE user_id=$1 ${
      isAdmin ? "" : "AND active=TRUE"
    } AND NOW() BETWEEN start_date AND end_date`,
    [userId]
  );
  return rows.map((r) => r.tier_id);
};

exports.listAvailableBooks = async ({
  tierIds,
  name,
  isAdmin,
  limit,
  offset,
  order,
}) => {
  if (!tierIds.length) return { totalItems: 0, items: [] };
  const { rows } = await pool.query(
    `WITH fb AS (
       SELECT DISTINCT b.*
       FROM books b
       JOIN tier_book_access tba ON b.id=tba.book_id
       WHERE tba.tier_id = ANY($1)
         ${isAdmin ? "" : "AND b.active=TRUE"}
         AND b.name ILIKE $2
     ), c AS (SELECT COUNT(*)::int AS total FROM fb)
     SELECT b.*, c.total FROM fb b, c
     ORDER BY b.name ${order === "desc" ? "DESC" : "ASC"}
     LIMIT $3 OFFSET $4`,
    [tierIds, `%${name || ""}%`, limit, offset]
  );
  const totalItems = rows[0]?.total || 0;
  return { totalItems, items: rows.map(({ total, ...r }) => r) };
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\access\access.routes.js ===
const express = require("express");
const auth = require("../../middleware/auth");
const ctrl = require("./access.controller");

const router = express.Router();
router.use(auth);
router.get("/books", ctrl.availableBooks);
module.exports = router;




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\access\access.service.js ===
const repo = require("./access.repository");
const { buildPagination } = require("../../utils/pagination");

exports.listAvailableBooks = async ({
  userId,
  isAdmin,
  page,
  pageSize,
  order,
  name,
}) => {
  const tierIds = await repo.getUserTierIdsActive({ userId, isAdmin });
  if (!tierIds.length)
    return { totalItems: 0, page: 1, pageSize: pageSize || 10, items: [] };
  const { limit, offset } = buildPagination(page || 1, pageSize || 10);
  return repo.listAvailableBooks({
    tierIds,
    name,
    isAdmin,
    limit,
    offset,
    order,
  });
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\auth\auth.controller.js ===
const Joi = require("joi");
const svc = require("./auth.service");
const v = require("./auth.validators");

const validate = (schema, payload) => {
  const { error, value } = schema.validate(payload, { abortEarly: false });
  if (error) {
    const err = new Error("Validation failed");
    err.status = 400;
    err.details = error.details.map((d) => d.message);
    throw err;
  }
  return value;
};

exports.signup = async (req, res, next) => {
  try {
    const data = validate(v.signup, req.body);
    const out = await svc.signup(data);
    res.status(201).json(out);
  } catch (e) {
    next(e);
  }
};

exports.login = async (req, res, next) => {
  try {
    const data = validate(v.login, req.body);
    const out = await svc.login(data);
    res.json(out);
  } catch (e) {
    next(e);
  }
};

exports.verifyEmail = async (req, res, next) => {
  try {
    const data = validate(v.verifyEmail, req.body);
    const out = await svc.verifyEmail(data);
    res.json(out);
  } catch (e) {
    next(e);
  }
};

exports.resetSend = async (req, res, next) => {
  try {
    const data = validate(v.resetSend, req.body);
    const out = await svc.resetSend(data);
    res.json(out);
  } catch (e) {
    next(e);
  }
};

exports.resetVerify = async (req, res, next) => {
  try {
    const data = validate(v.resetVerify, req.body);
    const out = await svc.resetVerify(data);
    res.json(out);
  } catch (e) {
    next(e);
  }
};

exports.googleLogin = async (req, res, next) => {
  try {
    const data = validate(v.google, req.body);
    const out = await svc.googleLogin(data);
    res.json(out);
  } catch (e) {
    next(e);
  }
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\auth\auth.repository.js ===
const pool = require("../../db");

exports.createUser = async ({ email, passwordHash, verifyCode }) => {
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    const { rows } = await client.query(
      `INSERT INTO users (email, password, verified, verify_code)
       VALUES ($1, $2, FALSE, $3) RETURNING id, email`,
      [email, passwordHash, verifyCode]
    );
    const userId = rows[0].id;
    await client.query(
      `INSERT INTO user_roles (user_id, role) VALUES ($1, 'user')`,
      [userId]
    );
    await client.query("COMMIT");
    return { id: userId, email };
  } catch (e) {
    await client.query("ROLLBACK");
    throw e;
  } finally {
    client.release();
  }
};

exports.findUserByEmail = async (email) => {
  const { rows } = await pool.query("SELECT * FROM users WHERE email=$1", [
    email,
  ]);
  return rows[0];
};

exports.setVerifyCode = async (email, code) => {
  await pool.query("UPDATE users SET verify_code=$1 WHERE email=$2", [
    code,
    email,
  ]);
};

exports.verifyEmail = async (email) => {
  await pool.query(
    "UPDATE users SET verified=TRUE, verify_code=NULL WHERE email=$1",
    [email]
  );
};

exports.setResetCode = async (email, code) => {
  await pool.query("UPDATE users SET reset_code=$1 WHERE email=$2", [
    code,
    email,
  ]);
};

exports.updatePasswordByEmail = async (email, hash) => {
  await pool.query(
    "UPDATE users SET password=$1, reset_code=NULL WHERE email=$2",
    [hash, email]
  );
};

exports.getUserRoles = async (userId) => {
  const { rows } = await pool.query(
    "SELECT role FROM user_roles WHERE user_id=$1",
    [userId]
  );
  return rows.map((r) => r.role);
};

exports.ensureUserWithGoogle = async (email) => {
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    const u = await client.query("SELECT id FROM users WHERE email=$1", [
      email,
    ]);
    let userId;
    if (!u.rows.length) {
      const ins = await client.query(
        "INSERT INTO users (email, verified) VALUES ($1, TRUE) RETURNING id",
        [email]
      );
      userId = ins.rows[0].id;
      await client.query(
        `INSERT INTO user_roles (user_id, role) VALUES ($1, 'user')`,
        [userId]
      );
    } else {
      userId = u.rows[0].id;
    }
    await client.query("COMMIT");
    return userId;
  } catch (e) {
    await client.query("ROLLBACK");
    throw e;
  } finally {
    client.release();
  }
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\auth\auth.routes.js ===
const express = require("express");
const ctrl = require("./auth.controller");
const router = express.Router();

router.post("/signup", ctrl.signup);
router.post("/login", ctrl.login);
router.post("/verify-email", ctrl.verifyEmail);
router.post("/reset/send-code", ctrl.resetSend);
router.post("/reset/verify", ctrl.resetVerify);
router.post("/google", ctrl.googleLogin);

module.exports = router;




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\auth\auth.service.js ===
const bcrypt = require("bcryptjs");
const { OAuth2Client } = require("google-auth-library");
const { GOOGLE_CLIENT_ID } = require("../../config");
const repo = require("./auth.repository");
const { send } = require("../../utils/email");
const { sign } = require("../../utils/jwt");

const googleClient = GOOGLE_CLIENT_ID
  ? new OAuth2Client(GOOGLE_CLIENT_ID)
  : null;

exports.signup = async ({ email, password }) => {
  const passwordHash = await bcrypt.hash(password, 10);
  const code = Math.floor(100000 + Math.random() * 900000).toString();
  const user = await repo.createUser({ email, passwordHash, verifyCode: code });
  await send({
    to: email,
    subject: "Verify Email",
    text: `Your code: ${code}`,
  });
  return { id: user.id, email: user.email };
};

exports.login = async ({ email, password }) => {
  const user = await repo.findUserByEmail(email);
  if (!user)
    throw Object.assign(new Error("Invalid credentials"), { status: 401 });
  const ok = await require("bcryptjs").compare(password, user.password || "");
  if (!ok)
    throw Object.assign(new Error("Invalid credentials"), { status: 401 });
  if (!user.verified)
    throw Object.assign(new Error("Email not verified"), { status: 401 });
  const roles = await repo.getUserRoles(user.id);
  const token = sign({ userId: user.id, roles });
  return { token , roles };
};

exports.verifyEmail = async ({ email, code }) => {
  const user = await repo.findUserByEmail(email);
  if (!user) throw Object.assign(new Error("User not found"), { status: 404 });
  if (user.verify_code !== code)
    throw Object.assign(new Error("Invalid code"), { status: 400 });
  await repo.verifyEmail(email);
  return { message: "Email verified" };
};

exports.resetSend = async ({ email }) => {
  const code = Math.floor(100000 + Math.random() * 900000).toString();
  await repo.setResetCode(email, code);
  await send({
    to: email,
    subject: "Password Reset Code",
    text: `Your code: ${code}`,
  });
  return { message: "Code sent" };
};

exports.resetVerify = async ({ email, code, newPassword }) => {
  const user = await repo.findUserByEmail(email);
  if (!user || user.reset_code !== code)
    throw Object.assign(new Error("Invalid code"), { status: 400 });
  const hash = await require("bcryptjs").hash(newPassword, 10);
  await repo.updatePasswordByEmail(email, hash);
  return { message: "Password updated" };
};

exports.googleLogin = async ({ token }) => {
  if (!googleClient)
    throw Object.assign(new Error("Google login not configured"), {
      status: 503,
    });
  const ticket = await googleClient.verifyIdToken({
    idToken: token,
    audience: GOOGLE_CLIENT_ID,
  });
  const email = ticket.getPayload().email;
  const userId = await repo.ensureUserWithGoogle(email);
  const roles = await repo.getUserRoles(userId);
  const jwt = sign({ userId, roles });
  return { token: jwt };
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\auth\auth.validators.js ===
const Joi = require("joi");

exports.signup = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().min(6).max(128).required(),
});

exports.login = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().required(),
});

exports.verifyEmail = Joi.object({
  email: Joi.string().email().required(),
  code: Joi.string().length(6).required(),
});

exports.resetSend = Joi.object({ email: Joi.string().email().required() });

exports.resetVerify = Joi.object({
  email: Joi.string().email().required(),
  code: Joi.string().length(6).required(),
  newPassword: Joi.string().min(6).max(128).required(),
});

exports.google = Joi.object({ token: Joi.string().required() });




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\books\book.controller.js ===
const v = require("./book.validators");
const svc = require("./book.service");

const validate = (schema, payload) => {
  const { error, value } = schema.validate(payload, { abortEarly: false });
  if (error) {
    const err = new Error("Validation failed");
    err.status = 400;
    err.details = error.details.map((d) => d.message);
    throw err;
  }
  return value;
};

exports.list = async (req, res, next) => {
  try {
    const q = validate(v.list, req.query);
    const out = await svc.listBooks({
      ...q,
      isAdmin: req.user?.roles?.includes("admin"),
    });
    res.json(out);
  } catch (e) {
    next(e);
  }
};

exports.create = async (req, res, next) => {
  try {
    const body = validate(v.create, req.body);
    const out = await svc.createBook(body);
    res.status(201).json(out);
  } catch (e) {
    next(e);
  }
};

exports.update = async (req, res, next) => {
  try {
    const body = validate(v.update, req.body);
    const out = await svc.updateBook(parseInt(req.params.id, 10), body);
    res.json(out);
  } catch (e) {
    next(e);
  }
};

exports.remove = async (req, res, next) => {
  try {
    await svc.deleteBook(parseInt(req.params.id, 10));
    res.status(204).send();
  } catch (e) {
    next(e);
  }
};

exports.listDetails = async (req, res, next) => {
  try {
    const items = await svc.listBookDetails({
      bookId: parseInt(req.params.bookId, 10),
      isAdmin: req.user?.roles?.includes("admin"),
    });
    res.json(items);
  } catch (e) {
    next(e);
  }
};

exports.getDetail = async (req, res, next) => {
  try {
    const detail = await svc.readBookDetailWithAccess({
      userId: req.user.userId,
      bookDetailId: parseInt(req.params.detailId, 10),
      isAdmin: req.user?.roles?.includes("admin"),
    });
    res.json(detail);
  } catch (e) {
    next(e);
  }
};

exports.createDetail = async (req, res, next) => {
  try {
    const body = validate(v.createDetail, req.body);
    const out = await svc.createBookDetail(body);
    res.status(201).json(out);
  } catch (e) {
    next(e);
  }
};

exports.updateDetail = async (req, res, next) => {
  try {
    const body = validate(v.updateDetail, req.body);
    const out = await svc.updateBookDetail(parseInt(req.params.id, 10), body);
    res.json(out);
  } catch (e) {
    next(e);
  }
};

exports.removeDetail = async (req, res, next) => {
  try {
    await svc.deleteBookDetail(parseInt(req.params.id, 10));
    res.status(204).send();
  } catch (e) {
    next(e);
  }
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\books\book.repository.js ===
const pool = require("../../db");

exports.listBooks = async ({ active, name, order, limit, offset }) => {
  const where = [];
  const values = [];
  let i = 1;
  if (typeof active === "boolean") {
    where.push(`active = $${i++}`);
    values.push(active);
  }
  if (name) {
    where.push(`name ILIKE $${i++}`);
    values.push(`%${name}%`);
  }
  const whereClause = where.length ? `WHERE ${where.join(" AND ")}` : "";
  const sql = `
    WITH fb AS (SELECT * FROM books ${whereClause}),
    c AS (SELECT COUNT(*)::int AS total FROM fb)
    SELECT b.*, c.total FROM fb b, c
    ORDER BY b.name ${order === "desc" ? "DESC" : "ASC"}
    LIMIT $${i++} OFFSET $${i}
  `;
  values.push(limit, offset);
  const { rows } = await pool.query(sql, values);
  const totalItems = rows[0]?.total || 0;
  return { totalItems, items: rows.map(({ total, ...r }) => r) };
};

exports.createBook = async ({ name, description, active = true }) => {
  const { rows } = await pool.query(
    `INSERT INTO books (name, description, active) VALUES ($1, $2, $3) RETURNING *`,
    [name, description, active]
  );
  return rows[0];
};

exports.updateBook = async (id, { name, description, active }) => {
  const { rows } = await pool.query(
    `UPDATE books SET name=COALESCE($1,name), description=COALESCE($2,description), active=COALESCE($3,active)
     WHERE id=$4 RETURNING *`,
    [name, description, active, id]
  );
  return rows[0];
};

exports.deleteBook = async (id) => {
  await pool.query("DELETE FROM books WHERE id=$1", [id]);
};

exports.listBookDetails = async ({ bookId, onlyActive }) => {
  const { rows } = await pool.query(
    `SELECT * FROM books_details WHERE book_id=$1 ${
      onlyActive ? "AND active=TRUE" : ""
    } ORDER BY name ASC`,
    [bookId]
  );
  return rows;
};

exports.getBookDetail = async (id, onlyActive) => {
  const { rows } = await pool.query(
    `SELECT * FROM books_details WHERE id=$1 ${
      onlyActive ? "AND active=TRUE" : ""
    }`,
    [id]
  );
  return rows[0];
};

exports.createBookDetail = async ({
  book_id,
  name,
  description,
  book_data,
  active = true,
}) => {
  const { rows } = await pool.query(
    `INSERT INTO books_details (book_id,name,description,book_data,active) VALUES ($1, $2, $3, $4, $5) RETURNING *`,
    [book_id, name, description, book_data, active]
  );
  return rows[0];
};

exports.updateBookDetail = async (
  id,
  { name, description, book_data, active }
) => {
  const { rows } = await pool.query(
    `UPDATE books_details SET 
    name=COALESCE($1,name), 
    description=COALESCE($2,description), 
    book_data=COALESCE($3,book_data), 
    active=COALESCE($4,active)
     WHERE id=$1 RETURNING *`,
    [name, description, book_data, active, id]
  );
  return rows[0];
};

exports.deleteBookDetail = async (id) => {
  await pool.query("DELETE FROM books_details WHERE id=$1", [id]);
};

exports.insertAccessLog = async ({ userId, bookDetailId }) => {
  await pool.query(
    "INSERT INTO user_book_access_log (user_id, book_detail_id) VALUES ($1,$2)",
    [userId, bookDetailId]
  );
};

exports.getUnlockRows = async ({ userId, bookDetailId, isAdmin }) => {
  const { rows } = await pool.query(
    `SELECT tba.unlock_delay_minutes, us.start_date
     FROM tier_book_access tba
     JOIN user_subscriptions us ON tba.tier_id = us.tier_id
     WHERE us.user_id=$1 AND tba.book_details_id=$2
       ${
         isAdmin ? "" : "AND us.active=TRUE"
       } AND NOW() BETWEEN us.start_date AND us.end_date`,
    [userId, bookDetailId]
  );
  return rows;
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\books\book.routes.js ===
const express = require("express");
const auth = require("../../middleware/auth");
const role = require("../../middleware/role");
const ctrl = require("./book.controller");

const router = express.Router();

router.use(auth);

// User & admin
router.get("/", ctrl.list);
router.get("/:bookId/details", ctrl.listDetails);
router.get("/details/:detailId", ctrl.getDetail); // guarded + logs access

// Admin CRUD
router.post("/", role("admin"), ctrl.create);
router.put("/:id", role("admin"), ctrl.update);
router.delete("/:id", role("admin"), ctrl.remove);

router.post("/details/", role("admin"), ctrl.createDetail);
router.put("/details/:id", role("admin"), ctrl.updateDetail);
router.delete("/details/:id", role("admin"), ctrl.removeDetail);

module.exports = router;




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\books\book.service.js ===
const repo = require("./book.repository");
const { buildPagination } = require("../../utils/pagination");

exports.listBooks = async ({ page, pageSize, name, order, isAdmin }) => {
  const { limit, offset } = buildPagination(page, pageSize);
  return repo.listBooks({
    active: isAdmin ? undefined : true,
    name,
    order,
    limit,
    offset,
  });
};

exports.createBook = (data) => repo.createBook(data);
exports.updateBook = (id, data) => repo.updateBook(id, data);
exports.deleteBook = (id) => repo.deleteBook(id);

exports.listBookDetails = ({ bookId, isAdmin }) =>
  repo.listBookDetails({ bookId, onlyActive: !isAdmin });

exports.readBookDetailWithAccess = async ({
  userId,
  bookDetailId,
  isAdmin,
}) => {
  // Check unlock policy
  const rows = await repo.getUnlockRows({ userId, bookDetailId, isAdmin });
  if (!rows.length && !isAdmin)
    throw Object.assign(new Error("Access denied"), { status: 403 });
  const blocked = rows.some((r) => {
    const unlock = new Date(r.start_date);
    unlock.setMinutes(unlock.getMinutes() + r.unlock_delay_minutes);
    return unlock > new Date();
  });
  if (blocked && !isAdmin)
    throw Object.assign(new Error("Book not unlocked yet"), { status: 403 });
  const detail = await repo.getBookDetail(bookDetailId, !isAdmin);
  if (!detail) throw Object.assign(new Error("Not found"), { status: 404 });
  await repo.insertAccessLog({ userId, bookDetailId });
  return detail;
};

exports.createBookDetail = (data) => repo.createBookDetail(data);
exports.updateBookDetail = (id, data) => repo.updateBookDetail(id, data);
exports.deleteBookDetail = (id) => repo.deleteBookDetail(id);




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\books\book.validators.js ===
const Joi = require("joi");
exports.create = Joi.object({
  name: Joi.string().min(1).required(),
  description: Joi.string().allow("", null),
  active: Joi.boolean().default(true),
});
exports.update = Joi.object({
  name: Joi.string().min(1),
  description: Joi.string().allow("", null),
  active: Joi.boolean(),
});
exports.list = Joi.object({
  page: Joi.number().integer().min(1).default(1),
  pageSize: Joi.number().integer().min(1).max(1000).default(50),
  name: Joi.string().allow("", null).default(""),
  order: Joi.string().valid("asc", "desc").default("asc"),
});

exports.createDetail = Joi.object({
  book_id: Joi.number().integer().min(1).required(),
  name: Joi.string().allow("", null),
  description: Joi.string().allow("", null),
  book_data: Joi.string().allow("", null),
  active: Joi.boolean().default(true),
});

exports.updateDetail = Joi.object({
  name: Joi.string().allow("", null),
  description: Joi.string().allow("", null),
  book_data: Joi.string().allow("", null),
  active: Joi.boolean(),
});




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\tiers\tier.controller.js ===
const v = require("./tier.validators");
const svc = require("./tier.service");

const validate = (schema, payload) => {
  const { error, value } = schema.validate(payload, { abortEarly: false });
  if (error) {
    const err = new Error("Validation failed");
    err.status = 400;
    err.details = error.details.map((d) => d.message);
    throw err;
  }
  return value;
};

exports.create = async (req, res, next) => {
  try {
    const out = await svc.create(validate(v.create, req.body));
    res.status(201).json(out);
  } catch (e) {
    next(e);
  }
};
exports.update = async (req, res, next) => {
  try {
    const out = await svc.update(
      parseInt(req.params.id, 10),
      validate(v.update, req.body)
    );
    res.json(out);
  } catch (e) {
    next(e);
  }
};
exports.remove = async (req, res, next) => {
  try {
    await svc.remove(parseInt(req.params.id, 10));
    res.status(204).send();
  } catch (e) {
    next(e);
  }
};
exports.list = async (req, res, next) => {
  try {
    const out = await svc.list(validate(v.list, req.query));
    res.json(out);
  } catch (e) {
    next(e);
  }
};
exports.upsertAccess = async (req, res, next) => {
  try {
    const out = await svc.upsertAccess({
      ...req.body,
      tier_id: parseInt(req.params.id, 10),
    });
    res.json(out);
  } catch (e) {
    next(e);
  }
};
exports.subscriptionsAdmin = async (req, res, next) => {
  try {
    const out = await svc.getSubsAdmin(req.query);
    res.json(out);
  } catch (e) {
    next(e);
  }
};
exports.logsAdmin = async (req, res, next) => {
  try {
    const out = await svc.getLogsAdmin(req.query);
    res.json(out);
  } catch (e) {
    next(e);
  }
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\tiers\tier.repository.js ===
const pool = require("../../db");

exports.createTier = async ({
  name,
  description,
  price = 0,
  duration_days = 30,
  active = true,
}) => {
  const { rows } = await pool.query(
    `INSERT INTO tiers (name, description, price, duration_days, active)
     VALUES ($1,$2,$3,$4,$5) RETURNING *`,
    [name, description, price, duration_days, active]
  );
  return rows[0];
};

exports.updateTier = async (id, data) => {
  const { name, description, price, duration_days, active } = data;
  const { rows } = await pool.query(
    `UPDATE tiers SET name=COALESCE($1,name), description=COALESCE($2,description), price=COALESCE($3,price), duration_days=COALESCE($4,duration_days), active=COALESCE($5,active)
     WHERE id=$6 RETURNING *`,
    [name, description, price, duration_days, active, id]
  );
  return rows[0];
};

exports.deleteTier = async (id) => {
  await pool.query("DELETE FROM tiers WHERE id=$1", [id]);
};

exports.listTiers = async ({ name, order, limit, offset }) => {
  const where = [];
  const values = [];
  let i = 1;
  if (name) {
    where.push(`t.name ILIKE $${i++}`);
    values.push(`%${name}%`);
  }
  const wc = where.length ? `WHERE ${where.join(" AND ")}` : "";
  const sql = `
    WITH ft AS (
      SELECT t.* FROM tiers t ${wc}
    ),
    aj AS (
      SELECT t.*, COALESCE(json_agg(json_build_object(
        'book_id', tba.book_id,
        'book_details_id', tba.book_details_id,
        'unlock_delay_minutes', tba.unlock_delay_minutes,
        'required', tba.required
      ) ORDER BY tba.book_id) FILTER (WHERE tba.id IS NOT NULL), '[]') AS access
      FROM ft t
      LEFT JOIN tier_book_access tba ON t.id=tba.tier_id
      GROUP BY t.id
    ),
    c AS (SELECT COUNT(*)::int AS total FROM ft)
    SELECT a.*, c.total FROM aj a, c
    ORDER BY a.name ${order === "desc" ? "DESC" : "ASC"}
    LIMIT $${i++} OFFSET $${i}
  `;
  values.push(limit, offset);
  const { rows } = await pool.query(sql, values);
  const totalItems = rows[0]?.total || 0;
  const items = rows.map(({ total, ...r }) => r);
  return { totalItems, items };
};

exports.upsertTierAccess = async ({
  tier_id,
  book_id,
  book_details_id = null,
  unlock_delay_minutes = 0,
  required = false,
}) => {
  const { rows } = await pool.query(
    `INSERT INTO tier_book_access (tier_id, book_id, book_details_id, unlock_delay_minutes, required)
     VALUES ($1,$2,$3,$4,$5)
     ON CONFLICT (tier_id, book_id, book_details_id)
     DO UPDATE SET unlock_delay_minutes=EXCLUDED.unlock_delay_minutes, required=EXCLUDED.required
     RETURNING *`,
    [tier_id, book_id, book_details_id, unlock_delay_minutes, required]
  );
  return rows[0];
};

exports.getUserSubscriptionsAdmin = async ({
  email,
  tier,
  user_id,
  limit,
  offset,
  order,
}) => {
  const where = [];
  const values = [];
  let i = 1;
  if (email) {
    where.push(`u.email ILIKE $${i++}`);
    values.push(`%${email}%`);
  }
  if (tier) {
    where.push(`t.name ILIKE $${i++}`);
    values.push(`%${tier}%`);
  }
  if (user_id) {
    where.push(`u.id=$${i++}`);
    values.push(user_id);
  }
  const wc = where.length ? `WHERE ${where.join(" AND ")}` : "";
  const sql = `
    WITH f AS (
      SELECT us.*, u.email, t.name AS tier_name
      FROM user_subscriptions us
      JOIN users u ON us.user_id=u.id
      JOIN tiers t ON us.tier_id=t.id
      ${wc}
    ), c AS (SELECT COUNT(*)::int AS total FROM f)
    SELECT f.*, c.total FROM f, c
    ORDER BY f.created_at ${order === "asc" ? "ASC" : "DESC"}
    LIMIT $${i++} OFFSET $${i}
  `;
  values.push(limit, offset);
  const { rows } = await pool.query(sql, values);
  const totalItems = rows[0]?.total || 0;
  const items = rows.map(({ total, ...r }) => r);
  return { totalItems, items };
};

exports.getAccessLogsAdmin = async ({
  email,
  book,
  user_id,
  limit,
  offset,
  order,
}) => {
  const where = [];
  const values = [];
  let i = 1;
  if (email) {
    where.push(`u.email ILIKE $${i++}`);
    values.push(`%${email}%`);
  }
  if (book) {
    where.push(`bd.name ILIKE $${i++}`);
    values.push(`%${book}%`);
  }
  if (user_id) {
    where.push(`u.id=$${i++}`);
    values.push(user_id);
  }
  const wc = where.length ? `WHERE ${where.join(" AND ")}` : "";
  const sql = `
    WITH f AS (
      SELECT u.email, bd.name AS book_detail, l.created_at
      FROM user_book_access_log l
      JOIN users u ON l.user_id=u.id
      JOIN books_details bd ON l.book_detail_id=bd.id
      ${wc}
    ), c AS (SELECT COUNT(*)::int AS total FROM f)
    SELECT f.*, c.total FROM f, c
    ORDER BY f.created_at ${order === "asc" ? "ASC" : "DESC"}
    LIMIT $${i++} OFFSET $${i}
  `;
  values.push(limit, offset);
  const { rows } = await pool.query(sql, values);
  const totalItems = rows[0]?.total || 0;
  const items = rows.map(({ total, ...r }) => r);
  return { totalItems, items };
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\tiers\tier.routes.js ===
const express = require("express");
const auth = require("../../middleware/auth");
const role = require("../../middleware/role");
const ctrl = require("./tier.controller");

const router = express.Router();
router.use(auth);

// Admin CRUD tiers
router.post("/", role("admin"), ctrl.create);
router.put("/:id", role("admin"), ctrl.update);
router.delete("/:id", role("admin"), ctrl.remove);
router.get("/", role("admin"), ctrl.list); // admin list with access aggregation

// Upsert access rules for a tier
router.put("/:id/access", role("admin"), ctrl.upsertAccess);

// Admin reports
router.get("/_admin/subscriptions", role("admin"), ctrl.subscriptionsAdmin);
router.get("/_admin/access-logs", role("admin"), ctrl.logsAdmin);

module.exports = router;




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\tiers\tier.service.js ===
const repo = require("./tier.repository");
const { buildPagination } = require("../../utils/pagination");

exports.create = (data) => repo.createTier(data);
exports.update = (id, data) => repo.updateTier(id, data);
exports.remove = (id) => repo.deleteTier(id);
exports.list = async ({ page, pageSize, name, order }) => {
  const { limit, offset } = buildPagination(page, pageSize);
  return repo.listTiers({ name, order, limit, offset });
};
exports.upsertAccess = (data) => repo.upsertTierAccess(data);
exports.getSubsAdmin = async (query) => {
  const { limit, offset } = require("../../utils/pagination").buildPagination(
    query.page,
    query.pageSize
  );
  return repo.getUserSubscriptionsAdmin({
    email: query.email,
    tier: query.tier,
    user_id: query.user_id,
    limit,
    offset,
    order: query.order || "desc",
  });
};
exports.getLogsAdmin = async (query) => {
  const { limit, offset } = require("../../utils/pagination").buildPagination(
    query.page,
    query.pageSize
  );
  return repo.getAccessLogsAdmin({
    email: query.email,
    book: query.book,
    user_id: query.user_id,
    limit,
    offset,
    order: query.order || "desc",
  });
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\tiers\tier.validators.js ===
const Joi = require("joi");
exports.create = Joi.object({
  name: Joi.string().min(1).required(),
  description: Joi.string().allow("", null),
  price: Joi.number().precision(9).min(0).default(0),
  duration_days: Joi.number().integer().min(1).default(30),
  active: Joi.boolean().default(true),
});
exports.update = Joi.object({
  name: Joi.string().min(1),
  description: Joi.string().allow("", null),
  price: Joi.number().precision(9).min(0),
  duration_days: Joi.number().integer().min(1),
  active: Joi.boolean(),
});
exports.list = Joi.object({
  page: Joi.number().integer().min(1).default(1),
  pageSize: Joi.number().integer().min(1).max(1000).default(50),
  name: Joi.string().allow("", null).default(""),
  order: Joi.string().valid("asc", "desc").default("asc"),
});




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\users\user.controller.js ===
const svc = require("./user.service");

exports.me = async (req, res, next) => {
  try {
    const out = await svc.getProfile(req.user.userId);
    res.json(out);
  } catch (e) {
    next(e);
  }
};

exports.subscribe = async (req, res, next) => {
  try {
    const tierId = parseInt(req.body.tier_id, 10);
    if (!tierId)
      throw Object.assign(new Error("tier_id required"), { status: 400 });
    const out = await svc.subscribeToTier({
      userId: req.user.userId,
      tierId,
      isAdmin: req.user.roles.includes("admin"),
    });
    res.status(201).json(out);
  } catch (e) {
    next(e);
  }
};

exports.mySubscriptions = async (req, res, next) => {
  try {
    const rows = await svc.getMySubscriptions(req.user.userId);
    res.json(rows);
  } catch (e) {
    next(e);
  }
};

exports.myAccessLog = async (req, res, next) => {
  try {
    const rows = await svc.getMyAccessLog(req.user.userId);
    res.json(rows);
  } catch (e) {
    next(e);
  }
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\users\user.repository.js ===
const pool = require("../../db");

exports.getProfile = async (userId) => {
  const { rows } = await pool.query(
    "SELECT id, email, verified, created_at FROM users WHERE id=$1",
    [userId]
  );
  return rows[0];
};

exports.getMySubscriptions = async (userId) => {
  const { rows } = await pool.query(
    `SELECT us.*, t.name AS tier_name
     FROM user_subscriptions us JOIN tiers t ON us.tier_id = t.id
     WHERE us.user_id=$1 ORDER BY us.created_at DESC`,
    [userId]
  );
  return rows;
};

exports.getMyAccessLog = async (userId) => {
  const { rows } = await pool.query(
    `SELECT bd.name, l.created_at
     FROM user_book_access_log l
     JOIN books_details bd ON l.book_detail_id = bd.id
     WHERE l.user_id=$1 ORDER BY l.created_at DESC`,
    [userId]
  );
  return rows;
};

exports.createSubscription = async ({ userId, tierId, startDate, endDate }) => {
  await pool.query(
    `INSERT INTO user_subscriptions (user_id, tier_id, start_date, end_date, active)
     VALUES ($1, $2, $3, $4, TRUE)`,
    [userId, tierId, startDate, endDate]
  );
};

exports.readTier = async (tierId, onlyActive) => {
  const { rows } = await pool.query(
    `SELECT * FROM tiers WHERE id=$1 ${onlyActive ? "AND active=TRUE" : ""}`,
    [tierId]
  );
  return rows[0];
};




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\users\user.routes.js ===
const express = require("express");
const auth = require("../../middleware/auth");
const ctrl = require("./user.controller");

const router = express.Router();

router.use(auth);
router.get("/me", ctrl.me);
router.post("/me/subscribe", ctrl.subscribe);
router.get("/me/subscriptions", ctrl.mySubscriptions);
router.get("/me/access-log", ctrl.myAccessLog);

module.exports = router;




=== FILE: D:\projects web\Private me\Server2\backend\src\modules\users\user.service.js ===
const repo = require("./user.repository");

exports.getProfile = async (userId) => repo.getProfile(userId);

exports.subscribeToTier = async ({ userId, tierId, isAdmin }) => {
  const tier = await repo.readTier(tierId, !isAdmin);
  if (!tier) throw Object.assign(new Error("Tier not found"), { status: 404 });
  const startDate = new Date();
  const endDate = new Date(startDate);
  endDate.setDate(endDate.getDate() + tier.duration_days);
  await repo.createSubscription({ userId, tierId, startDate, endDate });
  return { message: "Subscribed successfully" };
};

exports.getMySubscriptions = async (userId) => repo.getMySubscriptions(userId);
exports.getMyAccessLog = async (userId) => repo.getMyAccessLog(userId);




=== FILE: D:\projects web\Private me\Server2\backend\src\routes\index.js ===
const express = require("express");
const authRoutes = require("../modules/auth/auth.routes");
const userRoutes = require("../modules/users/user.routes");
const bookRoutes = require("../modules/books/book.routes");
const tierRoutes = require("../modules/tiers/tier.routes");
const accessRoutes = require("../modules/access/access.routes");

const router = express.Router();

router.use("/auth", authRoutes);
router.use("/users", userRoutes);
router.use("/books", bookRoutes);
router.use("/tiers", tierRoutes);
router.use("/access", accessRoutes); // admin access mgmt + logs

module.exports = router;




=== FILE: D:\projects web\Private me\Server2\backend\src\utils\email.js ===
const nodemailer = require("nodemailer");
const { EMAIL } = require("../config");

let transporter;
if (EMAIL.host && EMAIL.user && EMAIL.pass) {
  transporter = nodemailer.createTransport({
    host: EMAIL.host,
    port: EMAIL.port,
    secure: false,
    auth: { user: EMAIL.user, pass: EMAIL.pass },
  });
}

exports.send = async ({ to, subject, text }) => {
  if (!transporter) {
    console.log(`[email disabled] To:${to} Subject:${subject} Text:${text}`);
    return;
  }
  await transporter.sendMail({ from: EMAIL.user, to, subject, text });
};




=== FILE: D:\projects web\Private me\Server2\backend\src\utils\jwt.js ===
const jwt = require("jsonwebtoken");
const { JWT } = require("../config");
exports.sign = (payload, options = {}) =>
  jwt.sign(payload, JWT.secret, { expiresIn: JWT.expiresIn, ...options });




=== FILE: D:\projects web\Private me\Server2\backend\src\utils\pagination.js ===
exports.buildPagination = (page = 1, pageSize = 50) => {
  const p = Math.max(parseInt(page, 10) || 1, 1);
  const s = Math.min(Math.max(parseInt(pageSize, 10) || 50, 1), 1000);
  return { limit: s, offset: (p - 1) * s, page: p, pageSize: s };
};




